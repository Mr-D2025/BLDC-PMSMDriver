# 解读逐飞代码（老版）
逐飞代码分老版与新版，两个版本有较大不同，这里两个都分析一下

逐飞对电机的控制启动思路是，先预定位，再以开环低占空比拉到一个比较低的速度稳定后，最后切入闭环实现精确调速。
下面讲逐飞具体的算法代码实现。
## 总体系架构以及各个外设的功能
TIM1，用作系统定时器，给裸机系统运行的时候提供时间片。

usart1 用来下载程序。

PWMB 输入的PPM捕获测占空比duty。

PWMA 输出到FD6288驱动来驱动MOSFET。

TIM4 用于计时换向时间。

内置比较器 用于反电动势过零检测。

ADC电压检测

还有一个普通GPIO用来控制灯光。




## main函数与初始化
```c
//main.c
#include "motor.h"
#include "comparator.h"
#include "bldc_config.h"
#include "pwm.h"
#include "pwm_input.h"
#include "pit_timer.h"
#include "battery.h"
#include "headfile.h"



// 关于内核频率的设定，可以查看board.h文件
// 在board_init中,已经将P54引脚设置为复位
// 如果需要使用P54引脚,可以在board.c文件中的board_init()函数中删除SET_P54_RESRT即可

// 无刷电机LED状态灯说明
// 电池电压过低时，             LED亮0.1s    灭0.9s
// 电机遇到堵转，               LED亮0.05s   灭0.05s
// 电机未运行时，               LED亮1s      灭1s
// 电机开环启动中，             LED亮0.5s    灭0.5s
// 电机开环启动完成等待稳定中，  LED亮0.1s    灭0.1s
// 电机正常运行中，             LED常亮亮


void main()
{
    CKCON = 0;
    WTST = 0;               // 设置程序代码等待参数，赋值为0可将CPU执行程序的速度设置为最快
	  DisableGlobalIRQ();		// 关闭总中断
    sys_clk = 30000000;     // 设置系统频率为30000000Hz
  	board_init();			// 初始化寄存器
    EnableGlobalIRQ();		// 开启总中断
    download_flag = 0;
    
    // 此处编写用户代码(例如：外设初始化代码等)
    battery_init();         // 电池电压检测初始化
    led_init();             // LED初始化
    pwm_input_init();       // PWM输入捕获初始化
    comparator_init();      // 比较器初始化 
    motor_init();           // 电机相关初始化 

    // PWM初始化务必放在电机电机初始化函数之后，否则会烧毁电机
    // PWM初始化务必放在电机电机初始化函数之后，否则会烧毁电机
    // PWM初始化务必放在电机电机初始化函数之后，否则会烧毁电机
    pwm_center_init();      // PWM初始化 采用中心对齐         
	
  	pit_timer_init();       // 周期定时器初始化
	
    while(1)
	  {
    }
}

```
以上是老版的main.c文件，主要由一堆初始化组成，可以看到为了时效性，主要代码均在中断里面，此外与新版的最大区别在开启总中断时间不同。

```c

void board_init(void)
{
	EAXFR = 1;				// 使能访问XFR
	CKCON = 0x00;			// 设置外部数据总线为最快
	WTST = 0;               // 设置程序代码等待参数，赋值为0可将CPU执行程序的速度设置为最快
	SET_P54_RESRT;			// 使P54为复位引脚
	P_SW2 = 0x80;			// 开启特殊地址访问

#if (1 == EXTERNAL_CRYSTA_ENABLE)
	XOSCCR = 0xc0; 			//启动外部晶振
	while (!(XOSCCR & 1)); 	//等待时钟稳定
	CLKDIV = 0x00; 			//时钟不分频
	CLKSEL = 0x01; 			//选择外部晶振
#else
	//自动设置系统频率
	#if (0 == FOSC)
		sys_clk = set_clk();
	#else
		sys_clk = FOSC;
	#endif
#endif

	delay_init();			//延时函数初始化
	
	WTST = 0;
    P_SW2 |= 0x80;
    CLKDIV = 0;				//24MHz主频，分频设置
	
	P0M0 = 0x00;
	P0M1 = 0x00;
	P1M0 = 0x00;
	P1M1 = 0x00;
	P2M0 = 0x00;
	P2M1 = 0x00;
	P3M0 = 0x00;
	P3M1 = 0x00;
	P4M0 = 0x00;
	P4M1 = 0x00;
	P5M0 = 0x00;
	P5M1 = 0x00;
	P6M0 = 0x00;
	P6M1 = 0x00;
	P7M0 = 0x00;
	P7M1 = 0x00;
	
	ADCCFG = 0;
	AUXR = 0;
	SCON = 0;
	S2CON = 0;
	S3CON = 0;
	S4CON = 0;
	P_SW1 = 0;
	IE2 = 0;
	TMOD = 0;

	uart_init(DEBUG_UART, DEBUG_UART_RX_PIN, DEBUG_UART_TX_PIN, DEBUG_UART_BAUD, DEBUG_UART_TIM);
}
'''
这个函数是板子初始化函数，初始化了内存地址，时钟，引脚，以及一系列外设功能uart_init初始化下载程序用的串口。

```c
//-------------------------------------------------------------------------------------------------------------------
//  @brief      PWMB输入捕获初始化
//  @param      void                        
//  @return     void          
//  @since      v1.0
//  Sample usage:
//-------------------------------------------------------------------------------------------------------------------
void pwm_input_init(void)
{
    PWMB_PS = 0x0A;		// 通道引脚切换
    PWMB_CCMR1 = 0x01;	// CC5为输入模式,且映射到TI5FP5上
	PWMB_CCMR2 = 0x02;	// CC6为输入模式,且映射到TI5FP6上
    
	// CC5E 开启输入捕获
	// CC5P 捕获发生在TI5F的上升沿
	// CC6E 开启输入捕获
	// CC6P 捕获发生在TI5F的下降沿
    PWMB_CCER1 = 0x31;
    
    PWMB_PSCRH = 0;		// 分频值
	PWMB_PSCRL = sys_clk / 1000000 - 1;    // 分频值
    PWMB_SMCR = 0x54;	// TS=TI1FP1,SMS=TI1上升沿复位模式
	PWMB_CR1 = 0x01;	// 启动PWMB，向上计数
	PWMB_IER = 0x07;	// 使能CC1、CC2、UIE中断

    pwmin.period = 0;
    pwmin.high_value = 0;
    pwmin.high_time = 0;
}

```
这个函数配置了PWM输入捕获，测量外部ppm控制输入量，以相应的调速。
## 电机初始化
```c
typedef struct
{
    uint8   step;                   // 电机运行的步骤
    uint16  duty;                   // PWM占空比       用户改变电机速度时修改此变量
    uint16  duty_register;          // PWM占空比寄存器 用户不可操作 用于电机调速改变输出PWM的时候的赋值
    vuint8  run_flag;               // 电机正在运行标志位 0:已停止 1：正在启动 2：切入闭环之后再维持一段运行时间 3：启动完成正在运行
    float   motor_start_delay;      // 开环启动的换相的延时时间
    uint16  motor_start_wait;       // 开环启动时，换相时间已经降低到最小值后，统计换相的次数
    uint16  restart_delay;          // 电机延时重启
    uint16  commutation_failed_num; // 换相错误次数
    uint16  commutation_time[6];    // 最近6次换相时间
    uint32  commutation_time_sum;   // 最近6次换相时间总和
    uint32  commutation_num;        // 统计换相次数
    uint32  filter_commutation_time_sum;        // 统计换相次数
}motor_struct;


//-------------------------------------------------------------------------------------------------------------------
//  @brief      电机初始化
//  @param      void
//  @return     void
//  @since      v1.0
//  Sample usage:
//-------------------------------------------------------------------------------------------------------------------
void motor_init(void)
{
    // 变量清零
    motor.duty = 0;
    motor.duty_register = 0;
    motor.run_flag = 0;
    motor.motor_start_delay = 0;
    motor.motor_start_wait = 0;
    motor.restart_delay = 0;
    motor.commutation_time_sum = 0;
    motor.commutation_num = 0;
	
    T4T3M = 1<<7;	// 定时器4使能
    T4T3M |= 1<<5;	// T4 1T模式
    T4T3M |= 1<<3;	// 定时器3使能
    T4T3M |= 1<<1;	// T3 1T模式
    T3L = 0;
    T3H = 0;
    TM3PS = (sys_clk / 1000000) - 1;	// 设置分频系数，时基为1us
    T4L = 0;
    T4H = 0;
    TM4PS = (sys_clk / 1000000) - 1;	// 设置分频系数，时基为1us

    IP = 0;
    IPH = 0;
    IP2 = 0;
    IP2H = 0;
    // 设置比较器与PWM的中断为最高优先级
    IP |= 1<<7;
    IPH |= 1<<7;
    IP2 |= 1<<5;
    IP2H |= 1<<5;
#if (1 == BLDC_BEEP_ENABLE)
    // 电机鸣叫表示初始化完成
    motor_power_on_beep(BLDC_BEEP_VOLUME);
#endif
}
```
这是电机结构体与电机初始化，同时初始化了定时器3，4以及确定了中断优先级。

## 主循环
```c
//-------------------------------------------------------------------------------------------------------------------
//  @brief      定时器1中断
//  @param      void
//  @return     void
//  @since      v1.0
//  Sample usage:
//-------------------------------------------------------------------------------------------------------------------
void TM1_Isr() interrupt 3
{
    stime++;
    if(battery_voltage_get())
    {
        motor.run_flag = BYTE_LOW_VOLTAGE;
    }
    // 电池电压检测为最高优先级，当电压过低，就不转
    if(motor.run_flag != BYTE_LOW_VOLTAGE)
    {
        // 输入的占空比为0，则为空闲状态
        if(motor.duty == 0)
        {
            motor.run_flag = MOTOR_IDLE;
        }
        else
        {
            // 输入的占空比不为0，则从空闲状态转为电机开始
            if(motor.run_flag == MOTOR_IDLE)
            {
                motor.run_flag = MOTOR_START;
            }
        }
    }
    led_control();
    pit_motor_control();
}
```
## 输出PWM控制
```c

void pit_motor_control()
{
    uint16 temp_commutation_time = (T4H << 8) | T4L;
    static uint8 gpio_state = 0;
    uint8 motor_next_step_flag = 0;
    static uint16 stall_time_out_check = 0;
    static uint8 oled_pin_state = 0;
    uint8 pin_state = 0;
    switch(motor.run_flag)
    {
    case MOTOR_START:
    {
        comparator_close_isr();		// 关闭比较器中断
        IE2 = ~0x60;				// 关闭定时器3 定时器4中断
        // 设置启动占空比
        motor.duty_register = ((float)BLDC_START_VOLTAGE * BLDC_MAX_DUTY / ((float)battery_voltage/1000));
        pwm_center_duty_update(motor.duty_register);
        if(((T4H << 8) | T4L) > 20*1000)
        {
            motor.commutation_time[0] = 6000;
            motor.commutation_time[1] = 6000;
            motor.commutation_time[2] = 6000;
            motor.commutation_time[3] = 6000;
            motor.commutation_time[4] = 6000;
            motor.commutation_time[5] = 6000;
            motor.commutation_time_sum = motor.commutation_time[0] + motor.commutation_time[1] + motor.commutation_time[2] + \
                                         motor.commutation_time[3] + motor.commutation_time[4] + motor.commutation_time[5] ;
            // 清空定时器计数器值
            T4T3M &= ~0x80; // 停止定时器
            T4L = 0;
            T4H = 0;
            T4T3M |= 0x80;  // 开启定时器
            motor_next_step();
            motor_commutation();
            motor.run_flag = MOTOR_OPEN_LOOP;
            stall_time_out_check = 0;
            motor.commutation_num = 0;
        }
    }
    break;
    case MOTOR_OPEN_LOOP:
    {
        // 通过位移的方式，将电平数据存入变量中
        gpio_state = (gpio_state << 1) | (CMPCR1 & 0x01);
        if (!(motor.step % 2))
        {
            //下降沿
            if(gpio_state == 0)
            {
                motor_next_step_flag = 1;
                gpio_state = 0x0F;
            }
        }
        else
        {
            // 上升沿
            if(gpio_state == 0xFF)
            {
                motor_next_step_flag = 1;
                gpio_state = 0xF0;
            }
        }
        if(motor_next_step_flag)
        {
            T4T3M &= ~0x80; // 停止定时器
            T4L = 0;
            T4H = 0;
            T4T3M |= 0x80;  // 开启定时器
            // 堵转计数清空
            stall_time_out_check = 0;
            // 去掉最早的数据
            motor.commutation_time_sum -= motor.commutation_time[motor.step];
            // 保存换相时间
            motor.commutation_time[motor.step] = temp_commutation_time;
            // 叠加新的换相时间，求6次换相总时长
            motor.commutation_time_sum += motor.commutation_time[motor.step];
            // 换相次数增加一
            motor.commutation_num++;
            // 一阶低通滤波
            motor.filter_commutation_time_sum = (motor.filter_commutation_time_sum * 3 + motor.commutation_time_sum * 1) >> 2;
            // 等待30度
            while(((T4H << 8) | T4L) < (motor.filter_commutation_time_sum / 12));
            // 电机step加一
            motor_next_step();
            // 电机换相
            motor_commutation();
        }
        else
        {
            // 堵转检测
            if((10 * 200) < stall_time_out_check++)
            {
                stall_time_out_check = 0;
                motor.commutation_num = 0;
                motor.run_flag = MOTOR_STOP_STALL;
            }
        }
        // 闭环状态切换
        if((motor.commutation_num > (30 * 7)) && (motor.filter_commutation_time_sum < 8000))
        {
            // 清空计数器
            motor.commutation_failed_num = 0;
            // 清除一些变量
            motor.commutation_num = 0;
            stall_time_out_check = 0;
            // 打开比较器中断
            if(motor.step % 2)
            {
                comparator_rising();
            }
            else
            {
                comparator_falling();
            }
            // 使能定时器4中断
            IE2 |= 0x40;
            // 使能定时器4
            T4T3M |= 0x80;
            // 切换为闭环状态
            motor.run_flag = MOTOR_CLOSE_LOOP;
        }
        // 超过20ms没有检测到跳变，则从进入电机开始状态
        if(((T4H << 8) | T4L) > 20*1000)
        {
            T4T3M &= ~0x80; // 停止定时器
            T4L = 0;
            T4H = 0;
            T4T3M |= 0x80;  // 开启定时器
            // 电机step加一
            motor_next_step();
            // 电机换相
            motor_commutation();
            motor.run_flag = MOTOR_START;
        }
    }
    break;
    case MOTOR_CLOSE_LOOP:
    {
        pin_state = (CMPCR1 & 0x01);
        // 通过PA2引脚的电平状态，进行堵转检测
        if(oled_pin_state != pin_state)
        {
            stall_time_out_check = 0;
            oled_pin_state = pin_state;
        }
        else
        {
            // 如果引脚一直是一个状态，且超过了 BLDC_STALL_TIME_OUT ms 则认为堵转了
            if(stall_time_out_check++ > (10 * 200))          // 10KHZ，0.1ms计数一次
            {
                stall_time_out_check = 0;
                motor.run_flag = MOTOR_STOP_STALL;
            }
        }
    }
    break;
    case MOTOR_STOP_STALL:
    {
        motor_stop();
        IE2 = ~0x60;				// 关闭定时器3 定时器4中断
        comparator_close_isr();		// 关闭比较器中断
        motor.run_flag = MOTOR_RESTART;
        motor.restart_delay = BLDC_START_DELAY;
    }
    break;
    case MOTOR_RESTART:
    {
        if(motor.restart_delay)
        {
            // 延时启动时间减减
            motor.restart_delay--;
        }
        else
        {
            motor.run_flag = MOTOR_IDLE;
        }
    }
    break;
    case MOTOR_IDLE:
    case BYTE_LOW_VOLTAGE:
    {
        motor_stop();
    }
    break;
    }
}


```
这个函数基于状态机，包含完整的启动、运行、故障处理流程。在TIM1主循环中不断调用，实现对输出PWM的控制。

总体而言，这个函数实现电机启动的过程为，预定位，开环启动，闭环切入这三个步骤，以及一些必要的故障检测与解决措施。

先看状态机的每个状态

```c
typedef enum
{
    MOTOR_IDLE = 0,         // 0: 电机空闲/停止状态
    MOTOR_START,            // 1: 电机启动过程
    MOTOR_OPEN_LOOP,        // 2: 开环启动运行
    MOTOR_CLOSE_LOOP,       // 3: 闭环运行
    MOTOR_STOP_STALL,       // 4: 堵转停机
    MOTOR_RESTART,          // 5: 重启过程
    BYTE_LOW_VOLTAGE,       // 6: 低电压状态
} run_state_enum;
```
有7个状态，
下面对状态机的每个状态逐一解读

### 1: 电机启动过程 MOTOR_START
```c
case MOTOR_START:
    {
        comparator_close_isr();		// 关闭比较器中断
        IE2 = ~0x60;				// 关闭定时器3 定时器4中断
        // 设置启动占空比
        motor.duty_register = ((float)BLDC_START_VOLTAGE * BLDC_MAX_DUTY / ((float)battery_voltage/1000));
        pwm_center_duty_update(motor.duty_register);
        if(((T4H << 8) | T4L) > 20*1000)
        {
            motor.commutation_time[0] = 6000;
            motor.commutation_time[1] = 6000;
            motor.commutation_time[2] = 6000;
            motor.commutation_time[3] = 6000;
            motor.commutation_time[4] = 6000;
            motor.commutation_time[5] = 6000;
            motor.commutation_time_sum = motor.commutation_time[0] + motor.commutation_time[1] + motor.commutation_time[2] + \
                                         motor.commutation_time[3] + motor.commutation_time[4] + motor.commutation_time[5] ;
            // 清空定时器计数器值
            T4T3M &= ~0x80; // 停止定时器
            T4L = 0;
            T4H = 0;
            T4T3M |= 0x80;  // 开启定时器
            motor_next_step();
            motor_commutation();
            motor.run_flag = MOTOR_OPEN_LOOP;
            stall_time_out_check = 0;
            motor.commutation_num = 0;
        }
    }
    break;
```
这是开机前的准备步骤，
先关闭比较器中断和计时器中断（实际只有TIM4，关掉是因为要用TIM4计时记到20000），在计时器记到20ms之前，都是只给PWM占空比赋初值，记到20ms后，会初始化电机换相参数，清空定时器，电机换入下一步，MOSFET换相并输出PWM（只给某一相通电（小占空比），保证磁场方向只朝向一边，将转子强行拉到并固定在某一个方向，以便启动时知道转子在哪一相），状态机进入下一个状态，清空堵转计时与换向次数。（这步操作有一些迷惑，不知道为何要连续20ms都在初始化，可能是想20ms输出一相来强拉的，但不知道为何没有，之后可能要自己实验一下）。

这里几个换向间隔设成6ms，目的是设定开环旋转的时候的速度，6ms是因为速度适中，而且让commutation_time_sum可以被36整除。

### 2: 开环启动运行 MOTOR_OPEN_LOOP
```C
case MOTOR_OPEN_LOOP:
    {
        // 通过位移的方式，将电平数据存入变量中
        gpio_state = (gpio_state << 1) | (CMPCR1 & 0x01);
        if (!(motor.step % 2))
        {
            //下降沿
            if(gpio_state == 0)
            {
                motor_next_step_flag = 1;
                gpio_state = 0x0F;
            }
        }
        else
        {
            // 上升沿
            if(gpio_state == 0xFF)
            {
                motor_next_step_flag = 1;
                gpio_state = 0xF0;
            }
        }
        if(motor_next_step_flag)
        {
            T4T3M &= ~0x80; // 停止定时器
            T4L = 0;
            T4H = 0;
            T4T3M |= 0x80;  // 开启定时器
            // 堵转计数清空
            stall_time_out_check = 0;
            // 去掉最早的数据
            motor.commutation_time_sum -= motor.commutation_time[motor.step];
            // 保存换相时间
            motor.commutation_time[motor.step] = temp_commutation_time;
            // 叠加新的换相时间，求6次换相总时长
            motor.commutation_time_sum += motor.commutation_time[motor.step];
            // 换相次数增加一
            motor.commutation_num++;
            // 一阶低通滤波
            motor.filter_commutation_time_sum = (motor.filter_commutation_time_sum * 3 + motor.commutation_time_sum * 1) >> 2;
            // 等待30度
            while(((T4H << 8) | T4L) < (motor.filter_commutation_time_sum / 12));
            // 电机step加一
            motor_next_step();
            // 电机换相
            motor_commutation();
        }
        else
        {
            // 堵转检测
            if((10 * 200) < stall_time_out_check++)
            {
                stall_time_out_check = 0;
                motor.commutation_num = 0;
                motor.run_flag = MOTOR_STOP_STALL;
            }
        }
        // 闭环状态切换
        if((motor.commutation_num > (30 * 7)) && (motor.filter_commutation_time_sum < 8000))
        {
            // 清空计数器
            motor.commutation_failed_num = 0;
            // 清除一些变量
            motor.commutation_num = 0;
            stall_time_out_check = 0;
            // 打开比较器中断
            if(motor.step % 2)
            {
                comparator_rising();
            }
            else
            {
                comparator_falling();
            }
            // 使能定时器4中断
            IE2 |= 0x40;
            // 使能定时器4
            T4T3M |= 0x80;
            // 切换为闭环状态
            motor.run_flag = MOTOR_CLOSE_LOOP;
        }
        // 超过20ms没有检测到跳变，则从进入电机开始状态
        if(((T4H << 8) | T4L) > 20*1000)
        {
            T4T3M &= ~0x80; // 停止定时器
            T4L = 0;
            T4H = 0;
            T4T3M |= 0x80;  // 开启定时器
            // 电机step加一
            motor_next_step();
            // 电机换相
            motor_commutation();
            motor.run_flag = MOTOR_START;
        }
    }
    break;
```
这个是开环控制函数，处于开环状态的时候，比较器中断关闭，相当于再写了一边过零检测代码
```c
gpio_state = (gpio_state << 1) | (CMPCR1 & 0x01);
if (!(motor.step % 2))
{
	//下降沿
	if(gpio_state == 0)
	{
		motor_next_step_flag = 1;
		gpio_state = 0x0F;
	}
}
else
{
	// 上升沿
	if(gpio_state == 0xFF)
	{
		motor_next_step_flag = 1;
		gpio_state = 0xF0;
	}
}
```
CMPCR1 & 0x01取CMPCR1第一位，这个是比较器输出结果，
<img width="654" height="497" alt="image" src="https://github.com/user-attachments/assets/21d9a89b-6900-4f16-8a2d-ac3e0475b71a" />
由图片可以看到对过零检测而言，奇数次的都是下降沿，偶数次的都是上升沿，（由于step从0开始，所以其实代码中奇偶相反）。而刚进入开环控制状态前，预定位已经强行将转子拉到step=0的位子上了。

所以此函数要先判断处在哪一步，来确定是上升沿还是下降沿（这里是为了滤波），处于下降沿的时候，CMPCR1 & 0x01为0，连续四次低于0，就会让gpio_state为0，表示要换相，换相标志位置1，令gpio_state = 0x0F;因为下一次为上升沿，CMPCR1 & 0x01为1，连续四次低于1，就会让gpio_state为0xFF，表示要换相，换相标志位置1，令gpio_state = 0xF0;如此循环。
```c
if(motor_next_step_flag)
{
	T4T3M &= ~0x80; // 停止定时器
	T4L = 0;
	T4H = 0;
	T4T3M |= 0x80;  // 开启定时器
	// 堵转计数清空
	stall_time_out_check = 0;
	// 去掉最早的数据
	motor.commutation_time_sum -= motor.commutation_time[motor.step];
	// 保存换相时间
	motor.commutation_time[motor.step] = temp_commutation_time;
	// 叠加新的换相时间，求6次换相总时长
	motor.commutation_time_sum += motor.commutation_time[motor.step];
	// 换相次数增加一
	motor.commutation_num++;
	// 一阶低通滤波
	motor.filter_commutation_time_sum = (motor.filter_commutation_time_sum * 3 + motor.commutation_time_sum * 1) >> 2;
	// 等待30度
	while(((T4H << 8) | T4L) < (motor.filter_commutation_time_sum / 12));
	// 电机step加一
	motor_next_step();
	// 电机换相
	motor_commutation();
}
```
下一步，如果进入换相状态，停止定时器，清零，开启计时器，清除堵转计数，更新换相时间，使用低通滤波得到滤波后的换相时间，由上面反电动势的波形图可以得到，反电动势过零之后30°再换相，使用while等待。
```c
else
{
	// 堵转检测
	if((10 * 200) < stall_time_out_check++)
	{
		stall_time_out_check = 0;
		motor.commutation_num = 0;
		motor.run_flag = MOTOR_STOP_STALL;
	}
}
```
如果没有进入换相状态，堵转计时器++，当堵转超过200ms，认为堵转，立马停机。
```c
// 闭环状态切换
        if((motor.commutation_num > (30 * 7)) && (motor.filter_commutation_time_sum < 8000))
        {
            // 清空计数器
            motor.commutation_failed_num = 0;
            // 清除一些变量
            motor.commutation_num = 0;
            stall_time_out_check = 0;
            // 打开比较器中断
            if(motor.step % 2)
            {
                comparator_rising();
            }
            else
            {
                comparator_falling();
            }
            // 使能定时器4中断
            IE2 |= 0x40;
            // 使能定时器4
            T4T3M |= 0x80;
            // 切换为闭环状态
            motor.run_flag = MOTOR_CLOSE_LOOP;
        }
       
```
当开环运行超过210次换相且转速时间小于8ms时，切入闭环，清空计数器与一些变量，打开比较器中断（要根据当前位置判断是哪个方向方便滤波），使能定时器中断与定时器，状态位置成闭环运行。

```c
 // 超过20ms没有检测到跳变，则从进入电机开始状态
        if(((T4H << 8) | T4L) > 20*1000)
        {
            T4T3M &= ~0x80; // 停止定时器
            T4L = 0;
            T4H = 0;
            T4T3M |= 0x80;  // 开启定时器
            // 电机step加一
            motor_next_step();
            // 电机换相
            motor_commutation();
            motor.run_flag = MOTOR_START;
        }
```
超过20ms没有跳变就重新开始（这个函数可能会让堵转判断无法进入，这里的程序设计可能有些问题）。

###  3: 闭环运行 MOTOR_CLOSE_LOOP
```C
case MOTOR_CLOSE_LOOP:
    {
        pin_state = (CMPCR1 & 0x01);
        // 通过PA2引脚的电平状态，进行堵转检测
        if(oled_pin_state != pin_state)
        {
            stall_time_out_check = 0;
            oled_pin_state = pin_state;
        }
        else
        {
            // 如果引脚一直是一个状态，且超过了 BLDC_STALL_TIME_OUT ms 则认为堵转了
            if(stall_time_out_check++ > (10 * 200))          // 10KHZ，0.1ms计数一次
            {
                stall_time_out_check = 0;
                motor.run_flag = MOTOR_STOP_STALL;
            }
        }
    }
    break;
```
闭环的主要功能代码在比较器中断里面，这里主要就是堵转检测，利用oled_pin_state存储pin_state，如果引脚一直是一个状态，且超过了 BLDC_STALL_TIME_OUT ms 则认为堵转了。
### 其他
```c
case MOTOR_STOP_STALL:
    {
        motor_stop();
        IE2 = ~0x60;				// 关闭定时器3 定时器4中断
        comparator_close_isr();		// 关闭比较器中断
        motor.run_flag = MOTOR_RESTART;
        motor.restart_delay = BLDC_START_DELAY;
    }
    break;
    case MOTOR_RESTART:
    {
        if(motor.restart_delay)
        {
            // 延时启动时间减减
            motor.restart_delay--;
        }
        else
        {
            motor.run_flag = MOTOR_IDLE;
        }
    }
    break;
    case MOTOR_IDLE:
    case BYTE_LOW_VOLTAGE:
    {
        motor_stop();
    }
    break;
    }
```
这几个函数主要是堵转后的操作，堵转停机后，要过一会才能再转。

## 过零检测与初始化
无感无刷电机的换向判断是通过反电动势过零检测实现的，这里使用了STC自带的比较器来实现。
```c
//-------------------------------------------------------------------------------------------------------------------
//  @brief      比较器初始化
//  @param      void                        
//  @return     void          
//  @since      v1.0
//  Sample usage:
//-------------------------------------------------------------------------------------------------------------------
void comparator_init(void)
{
    gpio_mode(COMPARATOR_MID_PIN, GPI_IMPEDANCE); // 中性点
    gpio_mode(COMPARATOR_A_PIN  , GPI_IMPEDANCE); // A
	gpio_mode(COMPARATOR_B_PIN  , GPI_IMPEDANCE); // B
	gpio_mode(COMPARATOR_C_PIN  , GPI_IMPEDANCE); // C
    
    CMPCR1 = 0x8C;			// 1000 1100 打开比较器，P3.6作为比较器的反相输入端
	CMPCR2 = 63;				// 5个时钟滤波   比较结果变化延时周期数, 0~63
}


//-------------------------------------------------------------------------------------------------------------------
//  @brief      比较器中断函数
//  @param      void
//  @return     void
//  @since      v1.0
//  Sample usage:
//-------------------------------------------------------------------------------------------------------------------
void comparator_isr(void) interrupt 21		// 比较器中断函数, 检测到反电动势过0事件
{
    // 获取换相时间
    uint16 temp = (T4H << 8) | T4L;
    CMPCR1 &= ~0x40;	// 需软件清除中断标志位
	
// 去除反电动势毛刺
//    if((temp < (motor.commutation_time_sum / 24) && (30 * 7) < motor.commutation_num))
//    {
//        return;
//    }
	
    if(MOTOR_CLOSE_LOOP == motor.run_flag)
    {
        // 清空计数器
        T4T3M &= ~0x80; // 停止定时器
        T4L = 0;
        T4H = 0;
        T4T3M |= 0x80;  // 开启定时器
        // 去掉最早的数据
        motor.commutation_time_sum -= motor.commutation_time[motor.step];
        // 保存换相时间
        motor.commutation_time[motor.step] = temp;
        // 叠加新的换相时间，求6次换相总时长
        motor.commutation_time_sum += temp;
        motor.commutation_num++;
        // 本次换向60度的时间，在上一次换向一圈时间的50度到70度，否则认为换向错误
        if((temp > ((motor.commutation_time_sum / 36 * 5))) && (temp < (motor.commutation_time_sum / 36 * 7)))
        {
            // 延时减去换向失败计数器
            if((motor.commutation_failed_num))
            {
                motor.commutation_failed_num--;
            }
            // 缓慢加减速
            if(motor.duty != motor.duty_register)
            {
                if(0 == (motor.commutation_num%2) && (motor.duty_register != motor.duty))
                {
                    if(motor.duty > motor.duty_register)
                    {
                        motor.duty_register ++;
                        if(BLDC_MAX_DUTY < motor.duty_register)
                        {
                            motor.duty_register = BLDC_MAX_DUTY;
                        }
                    }
                    else
                    {
                        motor.duty_register = motor.duty;
                    }
                    pwm_center_duty_update(motor.duty_register);
                }
            }
        }
        else
        {
            if(BLDC_COMMUTATION_FAILED_MAX < motor.commutation_failed_num++)
            {
                motor_stop();
                motor.run_flag = MOTOR_STOP_STALL;
            }
        }
        // 修改PWM占空比

        motor_next_step();
        motor_commutation();
    }
}
```
这个换向判断的中断只有切入闭环后才会触发。
比较器初始化以及比较器中断函数，在比较器中断函数中检测过零事件，这里仔细分析一下后者的逻辑。
首先，采用六步换向的方法，同一时刻只有两相有管子开通，此时使用另一相来进行反电动势检测，注意检测反电动势的相必须两个管子均关断，否则电压不对。

1.当反电动势过零的时候进入中断

2.进入中断后，获取换向间隔时间（从定时器4中），清除中断标志位

```c
// 获取换相时间
    uint16 temp = (T4H << 8) | T4L;
    CMPCR1 &= ~0x40;	// 需软件清除中断标志位
```

3.判断电机是否处于闭环模式（利用电机结构体的一个标志位），如果是的话则清空计时器的值（关，清空，开），再更新最新六次换向时间的记录（利用一个数组（循环写入）），具体操作sum中减去老的，数组中替换为新的，sum加上新的。
然后利用这个换向时间的平均来判断这此换向是否正确（判断方法：本次换向60度的时间，在上一次换向一圈时间的50度到70度，否则认为换向错误）。

4.换向错误则增加换向次数并进入错误次数判断，如果超过最大换向错误界限了，就停车。
```c
if(BLDC_COMMUTATION_FAILED_MAX < motor.commutation_failed_num++)
```

5.换向成功，就先减去一个换向失败计数器（相当于成功换向一次可以抵消一个换向失败，需要多次连续成功换相才能将计数器归零，不清零是为了增强抵抗性）。
之后缓慢加减速
```c
// 缓慢加减速
            if(motor.duty != motor.duty_register)
            {
                if(0 == (motor.commutation_num%2) && (motor.duty_register != motor.duty))
                {
                    if(motor.duty > motor.duty_register)
                    {
                        motor.duty_register ++;
                        if(BLDC_MAX_DUTY < motor.duty_register)
                        {
                            motor.duty_register = BLDC_MAX_DUTY;
                        }
                    }
                    else
                    {
                        motor.duty_register = motor.duty;
                    }
                    pwm_center_duty_update(motor.duty_register);
                }
            }

```
如果在这个时候外部控制改变了输入的PPM进行调速，控制电机的占空比不等于占空比寄存器的话（如果刚开机的时候，开环启动，这里占空比寄存器被赋了一个值
```c
// 设置启动占空比
        motor.duty_register = ((float)BLDC_START_VOLTAGE * BLDC_MAX_DUTY / ((float)battery_voltage/1000));，
```
刚切入闭环后这个值可能与ppm要求设置的不一样，不是刚切入的话之后会根据上一次判断不断加值），进入是高了还是低了的判断
```c
if(0 == (motor.commutation_num%2) && (motor.duty_register != motor.duty))
```
这一句保证了六相中只加减速三次），如果实际的比设置的高，则缓慢加速，反之则立马减速。

6.最后换向
```c
motor_next_step();
motor_commutation();
```

tips.另外还有TIM4中断，如果换向计时时间超时会停机。
另外，这里换相没有等30°，可能会是个问题。

## 换相与PWM输出函数
```c

//-------------------------------------------------------------------------------------------------------------------
//  @brief      电机step加一
//  @param      void
//  @return
//  @since      v1.0
//  Sample usage:
//-------------------------------------------------------------------------------------------------------------------
void motor_next_step(void)
{
    motor.step++;
    while(6 <= motor.step)
    {
        motor.step -= 6;
    }
}

//-------------------------------------------------------------------------------------------------------------------
//  @brief      电机换相函数
//  @param      void
//  @return
//  @since      v1.0
//  Sample usage:
//-------------------------------------------------------------------------------------------------------------------
void motor_commutation(void)
{
    switch(motor.step)
    {
		case 0:
		{
			pwm_a_bn_output();
			if(MOTOR_CLOSE_LOOP == motor.run_flag)
			{
				comparator_falling();
			}
		}
		break;
		case 1:
		{
			pwm_a_cn_output();
			if(MOTOR_CLOSE_LOOP == motor.run_flag)
			{
				comparator_rising();
			}
		}
		break;
		case 2:
		{
			pwm_b_cn_output();
			if(MOTOR_CLOSE_LOOP == motor.run_flag)
			{
				comparator_falling();
			}
		}
		break;
		case 3:
		{
			pwm_b_an_output();
			if(MOTOR_CLOSE_LOOP == motor.run_flag)
			{
				comparator_rising();
			}
		}
		break;
		case 4:
		{
			pwm_c_an_output();
			if(MOTOR_CLOSE_LOOP == motor.run_flag)
			{
				comparator_falling();
			}
		}
		break;
		case 5:
		{
			pwm_c_bn_output();
			if(MOTOR_CLOSE_LOOP == motor.run_flag)
			{
				comparator_rising();
			}
		}
		break;
		default:
			break;
    }
}
//-------------------------------------------------------------------------------------------------------------------
//  @brief      开启A上B下
//  @param      void                        
//  @return     void          
//  @since      v1.0
//  Sample usage:
//-------------------------------------------------------------------------------------------------------------------
void pwm_a_bn_output(void)
{
    pwm_close_output();
    delay_500ns();
    PWMA_ENO = 1<<0;
    PWM_B_L_PIN = 1;
    comparator_select_c();
}


```
这三个分别为步进函数，换相（其实是按相PWM输出）函数，以及以ABn为例的PWM输出函数。
```c
 PWMA_ENO = 1<<0; //开启A上桥臂PWM
    PWM_B_L_PIN = 1; //常开B

```




